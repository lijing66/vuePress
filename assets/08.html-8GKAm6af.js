import{_ as e,o as p,c as a,b as r}from"./app-du5sw6ua.js";const t={},c=r('<h1 id="三次握手和四次挥手" tabindex="-1"><a class="header-anchor" href="#三次握手和四次挥手" aria-hidden="true">#</a> 三次握手和四次挥手</h1><h2 id="简版" tabindex="-1"><a class="header-anchor" href="#简版" aria-hidden="true">#</a> 简版</h2><p>三次握手是为了确认双方的接收与发送能力是否正常。</p><p>1、第一次握手：客户端给服务器发送一个 SYN 报文。</p><p>2、第二次握手：服务器收到 SYN 报文之后，会应答一个 SYN+ACK 报文。</p><p>3、第三次握手：客户端收到 SYN+ACK 报文之后，会回应一个 ACK 报文。 服务器收到 ACK 报文之后，三次握手建立完成。</p><p>当客户端和服务端通过三次握手建立 TCP 连接进行可靠数据传输后，当数据传送完毕，肯定是要断开 TCP 连接，所以就有了四次挥手。</p><p>四次挥手是为了断开连接后「资源」正常释放，双方都可以主动断开连接。</p><p>1、第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。</p><p>2、第二次握手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 + 1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。</p><p>3、第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。</p><p>4、第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态</p><p>5、服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。</p><h3 id="扩展理解" tabindex="-1"><a class="header-anchor" href="#扩展理解" aria-hidden="true">#</a> 扩展理解</h3><p>为什么只有三次握手才能确认双方的接受与发送能力是否正常，而两次却不可以：</p><p>第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</p><p>第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。</p><p>第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</p><p>因此，需要三次握手才能确认双方的接收与发送能力是否正常。</p>',19),h=[c];function d(n,_){return p(),a("div",null,h)}const s=e(t,[["render",d],["__file","08.html.vue"]]);export{s as default};
